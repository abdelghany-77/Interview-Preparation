const questions = {
  docker: {
    easy: [
      {
        q: "What is Docker?",
        a: "Docker is an open-source platform that enables developers to automate the deployment of applications inside lightweight, portable containers. Containers package an application with all its dependencies and libraries, ensuring it runs consistently across different environments. Docker simplifies development, testing, and deployment workflows.",
      },
      {
        q: "What is a Container?",
        a: "A container is a lightweight, standalone, executable package that includes everything needed to run a piece of software: code, runtime, system tools, libraries, and settings. Containers isolate software from its environment and ensure it works uniformly despite differences between development and staging.",
      },
      {
        q: "What is a Docker Image?",
        a: "A Docker image is a read-only template with instructions for creating a Docker container. Images are built from a Dockerfile and can be stored in Docker Hub or private registries. They contain the application code, runtime, libraries, and dependencies needed to run an application.",
      },
      {
        q: "What is Docker Hub?",
        a: "Docker Hub is a cloud-based registry service that allows you to link to code repositories, build images, test them, store manually pushed images, and link to Docker Cloud for deployment. It provides both public and private repositories for Docker images.",
      },
      {
        q: "What is a Dockerfile?",
        a: "A Dockerfile is a text file that contains instructions for building a Docker image. It specifies the base image, application code, dependencies, environment variables, and commands needed to configure and run the container. Each instruction in a Dockerfile creates a layer in the image.",
      },
      {
        q: "What is the difference between Docker and Virtual Machines?",
        a: "Containers share the host OS kernel and are more lightweight, starting in seconds with minimal resource usage. Virtual Machines include a full OS copy, hypervisor layer, and are heavier (GBs), taking minutes to start. Containers provide process-level isolation, while VMs provide complete isolation.",
      },
      {
        q: "What is Docker Compose?",
        a: "Docker Compose is a tool for defining and running multi-container Docker applications. Using a YAML file (docker-compose.yml), you can configure application services, networks, and volumes. With a single command (docker-compose up), you can create and start all services.",
      },
      {
        q: "What are Docker registries?",
        a: "Docker registries are repositories for storing and distributing Docker images. Docker Hub is the default public registry, but you can also use private registries like Amazon ECR, Google Container Registry, or Azure Container Registry for secure, organization-specific image storage.",
      },
      {
        q: "What is the Docker Engine?",
        a: "Docker Engine is the core component of Docker. It's a client-server application consisting of: 1) A server (dockerd daemon) that runs containers, 2) A REST API for interaction, 3) A CLI client (docker) for commands. It manages containers, images, networks, and volumes.",
      },
      {
        q: "What is a Docker volume?",
        a: "Docker volumes are the preferred mechanism for persisting data generated by and used by Docker containers. Unlike bind mounts, volumes are completely managed by Docker, can be safely shared among containers, and work on both Linux and Windows containers.",
      },
      {
        q: "What is Docker Swarm?",
        a: "Docker Swarm is Docker's native clustering and orchestration tool. It turns a pool of Docker hosts into a single virtual host, enabling you to scale services, perform rolling updates, and achieve high availability. It's an alternative to Kubernetes for container orchestration.",
      },
      {
        q: "What is a base image?",
        a: "A base image is the starting point for building Docker images. It's the parent image specified in the FROM instruction of a Dockerfile. Common base images include official images like ubuntu, alpine, node, python, or nginx from Docker Hub.",
      },
      {
        q: "What is Docker networking?",
        a: "Docker networking allows containers to communicate with each other and the outside world. Docker provides several network drivers: bridge (default for standalone containers), host (removes network isolation), overlay (for swarm services), macvlan (assigns MAC addresses), and none (disables networking).",
      },
      {
        q: "What is the purpose of Docker tags?",
        a: "Docker tags are labels applied to images to identify different versions or variants. Tags help in version control and allow pulling specific image versions. For example, 'nginx:latest' and 'nginx:1.21' are different tags of the nginx image.",
        example: `docker pull nginx:latest
docker pull nginx:1.21-alpine
docker tag myapp:latest myapp:v1.0`,
      },
      {
        q: "What is a Docker layer?",
        a: "A Docker layer is a modification made to a Docker image. Each instruction in a Dockerfile creates a new layer. Layers are stacked on top of each other, and Docker uses a union file system to combine them. Layers are cached and reused to improve build performance.",
      },
      {
        q: "What is the docker run command?",
        a: "The 'docker run' command creates and starts a container from an image. It combines docker create and docker start. You can specify options like port mapping, volume mounts, environment variables, and run modes (detached/interactive).",
        example: `docker run -d -p 8080:80 --name webserver nginx
# -d: detached mode
# -p: port mapping (host:container)
# --name: container name`,
      },
      {
        q: "What is the docker ps command?",
        a: "The 'docker ps' command lists running containers. Use 'docker ps -a' to show all containers (including stopped ones). It displays container ID, image, command, creation time, status, ports, and names.",
        example: `docker ps           # Running containers
docker ps -a        # All containers
docker ps -q        # Only container IDs`,
      },
      {
        q: "What is the docker images command?",
        a: "The 'docker images' command lists all Docker images stored locally on your system. It shows repository name, tag, image ID, creation date, and size. This helps track available images for running containers.",
        example: `docker images
docker images -a    # Show all images including intermediates
docker images -q    # Show only image IDs`,
      },
      {
        q: "What is the docker pull command?",
        a: "The 'docker pull' command downloads an image from a Docker registry (like Docker Hub) to your local machine. You can specify a tag to pull a specific version, otherwise 'latest' is used by default.",
        example: `docker pull ubuntu
docker pull ubuntu:20.04
docker pull nginx:alpine`,
      },
      {
        q: "What is the docker stop command?",
        a: "The 'docker stop' command gracefully stops a running container by sending a SIGTERM signal, then SIGKILL after a grace period (default 10 seconds). This allows the container to clean up resources before termination.",
        example: `docker stop container_name
docker stop container_id
docker stop $(docker ps -q)  # Stop all running containers`,
      },
    ],
    medium: [
      {
        q: "What is the FROM instruction in Dockerfile?",
        a: "The FROM instruction initializes a new build stage and sets the base image for subsequent instructions. It must be the first instruction in a Dockerfile (except for ARG used before FROM). You can use multiple FROM instructions to create multi-stage builds.",
        example: `FROM ubuntu:20.04
FROM node:18-alpine
FROM nginx:latest`,
      },
      {
        q: "What is the RUN instruction in Dockerfile?",
        a: "The RUN instruction executes commands in a new layer on top of the current image and commits the results. It's used to install packages, create directories, or run build steps. Use '&&' to chain commands and reduce layers.",
        example: `RUN apt-get update && apt-get install -y \\
    python3 \\
    python3-pip \\
    && rm -rf /var/lib/apt/lists/*
    
RUN npm install`,
      },
      {
        q: "What is the CMD instruction in Dockerfile?",
        a: "The CMD instruction provides default arguments for the container's main process. There can only be one CMD per Dockerfile. If multiple exist, only the last takes effect. CMD can be overridden by docker run arguments. It's typically used to start the application.",
        example: `CMD ["npm", "start"]
CMD ["python3", "app.py"]
CMD ["nginx", "-g", "daemon off;"]`,
      },
      {
        q: "What is the ENTRYPOINT instruction in Dockerfile?",
        a: "The ENTRYPOINT instruction configures a container to run as an executable. Unlike CMD, ENTRYPOINT is not easily overridden (requires --entrypoint flag). It's best used when the container should always run the same executable, with CMD providing default parameters.",
        example: `ENTRYPOINT ["python3", "app.py"]
# Or combine with CMD for default args:
ENTRYPOINT ["docker-entrypoint.sh"]
CMD ["postgres"]`,
      },
      {
        q: "What is the difference between CMD and ENTRYPOINT?",
        a: "CMD provides default commands/parameters that can be easily overridden by docker run arguments. ENTRYPOINT defines the executable that always runs, with docker run arguments appended to it. Best practice: use ENTRYPOINT for the main executable and CMD for default parameters.",
        example: `# CMD can be overridden
CMD ["echo", "Hello"]
docker run myimage echo "Goodbye"  # Runs "echo Goodbye"

# ENTRYPOINT is not overridden
ENTRYPOINT ["echo"]
CMD ["Hello"]
docker run myimage "Goodbye"  # Runs "echo Goodbye"`,
      },
      {
        q: "What is the COPY instruction in Dockerfile?",
        a: "The COPY instruction copies files and directories from the build context (host) into the container's filesystem. It's simpler and more predictable than ADD, making it preferred for basic file copying operations.",
        example: `COPY package.json /app/
COPY . /app/
COPY --chown=user:group files* /app/`,
      },
      {
        q: "What is the ADD instruction in Dockerfile?",
        a: "The ADD instruction copies files/directories like COPY but with additional features: automatic tar extraction and remote URL support. However, due to its complexity and unpredictability, COPY is preferred unless you specifically need tar extraction or URL downloads.",
        example: `ADD https://example.com/file.tar.gz /tmp/
ADD app.tar.gz /app/  # Auto-extracts tar
ADD files/ /app/`,
      },
      {
        q: "What is the difference between COPY and ADD?",
        a: "COPY is a simple, straightforward instruction for copying files from host to container. ADD has additional features (auto-extracting tars, downloading URLs) but is less predictable. Best practice: use COPY unless you specifically need ADD's extra functionality.",
      },
      {
        q: "What is the ENV instruction in Dockerfile?",
        a: "The ENV instruction sets environment variables in the image. These variables persist when a container runs and can be used by subsequent Dockerfile instructions. They can be overridden at runtime using docker run -e.",
        example: `ENV NODE_ENV=production
ENV APP_HOME=/app \\
    APP_USER=appuser
    
RUN echo $APP_HOME  # Uses the variable`,
      },
      {
        q: "What is the EXPOSE instruction in Dockerfile?",
        a: "The EXPOSE instruction documents which ports the container listens on at runtime. It doesn't actually publish the ports - that's done with 'docker run -p'. EXPOSE serves as documentation and is used by 'docker run -P' to auto-publish all exposed ports.",
        example: `EXPOSE 80
EXPOSE 8080/tcp
EXPOSE 443/tcp`,
      },
      {
        q: "What is the WORKDIR instruction in Dockerfile?",
        a: "The WORKDIR instruction sets the working directory for subsequent RUN, CMD, ENTRYPOINT, COPY, and ADD instructions. If the directory doesn't exist, it's created. Using WORKDIR is preferred over 'RUN cd' as it's clearer and more reliable.",
        example: `WORKDIR /app
COPY package.json .
RUN npm install
COPY . .`,
      },
      {
        q: "What is the LABEL instruction in Dockerfile?",
        a: "The LABEL instruction adds metadata to an image as key-value pairs. Labels can store information like version, description, maintainer, or any custom metadata. They don't affect container runtime but help with organization and automation.",
        example: `LABEL version="1.0"
LABEL description="My application"
LABEL maintainer="dev@example.com"
LABEL multi.label1="value1" \\
      multi.label2="value2"`,
      },
      {
        q: "What is the VOLUME instruction in Dockerfile?",
        a: "The VOLUME instruction creates a mount point with the specified path and marks it as holding externally mounted volumes. It's used to persist data and share data between containers. Volumes outlive containers and can be managed independently.",
        example: `VOLUME /data
VOLUME /var/log /var/db
# At runtime:
docker run -v mydata:/data myimage`,
      },
      {
        q: "What is the docker exec command?",
        a: "The 'docker exec' command runs a new command in an already running container. It's commonly used to access a container's shell for debugging or to execute maintenance tasks without stopping the container.",
        example: `docker exec -it container_name bash
docker exec container_name ls /app
docker exec -it container_name sh  # For alpine images`,
      },
      {
        q: "What is the docker logs command?",
        a: "The 'docker logs' command fetches logs from a container. It shows stdout and stderr output from the container's main process. Useful for debugging and monitoring application behavior.",
        example: `docker logs container_name
docker logs -f container_name     # Follow log output
docker logs --tail 100 container_name
docker logs --since 30m container_name`,
      },
      {
        q: "What is the docker build command?",
        a: "The 'docker build' command builds a Docker image from a Dockerfile and a build context. It reads instructions from the Dockerfile and creates layers for each instruction, utilizing caching to speed up subsequent builds.",
        example: `docker build -t myapp:latest .
docker build -t myapp:v1.0 -f Dockerfile.prod .
docker build --no-cache -t myapp .`,
      },
      {
        q: "What is Docker layer caching?",
        a: "Docker caches each layer during build. If an instruction hasn't changed and its dependencies are the same, Docker reuses the cached layer instead of rebuilding. This dramatically speeds up builds. Caching breaks when an instruction or context changes.",
        example: `# Good: Dependencies cached separately
COPY package.json .
RUN npm install
COPY . .

# Bad: Changes to code invalidate npm install cache
COPY . .
RUN npm install`,
      },
      {
        q: "What is a multi-stage build?",
        a: "Multi-stage builds use multiple FROM statements in a single Dockerfile. Each FROM starts a new build stage. You can copy artifacts from one stage to another, leaving behind unnecessary build tools and dependencies. This creates smaller, more secure production images.",
        example: `# Build stage
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Production stage
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
CMD ["node", "dist/main.js"]`,
      },
      {
        q: "What is docker-compose.yml?",
        a: "docker-compose.yml is a YAML configuration file that defines services, networks, and volumes for multi-container applications. It allows you to configure and run multiple containers with a single command, making it ideal for development environments and simple deployments.",
        example: `version: '3.8'
services:
  web:
    build: .
    ports:
      - "8080:80"
    depends_on:
      - db
  db:
    image: postgres:13
    environment:
      POSTGRES_PASSWORD: secret
    volumes:
      - pgdata:/var/lib/postgresql/data
volumes:
  pgdata:`,
      },
      {
        q: "What is the docker rm command?",
        a: "The 'docker rm' command removes one or more stopped containers. Use 'docker rm -f' to forcefully remove running containers. This frees up system resources and cleans up container metadata.",
        example: `docker rm container_name
docker rm -f running_container
docker rm $(docker ps -a -q)  # Remove all stopped containers`,
      },
    ],
    hard: [
      {
        q: "What is the difference between docker stop and docker kill?",
        a: "docker stop sends SIGTERM (graceful shutdown) followed by SIGKILL after timeout, allowing cleanup. docker kill immediately sends SIGKILL, forcefully terminating the process without cleanup. Use stop for normal shutdown, kill only when stop fails.",
        example: `docker stop web-app        # Graceful shutdown (10s timeout)
docker stop -t 30 web-app  # Custom timeout
docker kill web-app        # Force kill immediately`,
      },
      {
        q: "What is the docker restart command?",
        a: "The 'docker restart' command stops and starts a container. It's equivalent to docker stop followed by docker start. The restart policy can be configured to automatically restart containers on failure or system reboot.",
        example: `docker restart container_name
docker restart -t 30 container_name  # Wait 30s before kill

# Set restart policy
docker run --restart=always nginx
docker run --restart=on-failure:5 myapp`,
      },
      {
        q: "What is the docker inspect command?",
        a: "The 'docker inspect' command returns detailed low-level information about Docker objects (containers, images, volumes, networks) in JSON format. It shows configuration, network settings, mounts, environment variables, and more.",
        example: `docker inspect container_name
docker inspect --format='{{.NetworkSettings.IPAddress}}' container
docker inspect --format='{{json .Config.Env}}' container`,
      },
      {
        q: "What is the docker rmi command?",
        a: "The 'docker rmi' command removes one or more images from the local system. Images must not be used by any containers (stopped or running). Use -f to force removal, which also removes containers using the image.",
        example: `docker rmi image_name
docker rmi image_id
docker rmi $(docker images -q)  # Remove all images`,
      },
      {
        q: "What are Docker best practices for Dockerfile?",
        a: "Best practices include: 1) Use official base images, 2) Minimize layers by combining RUN commands, 3) Use .dockerignore, 4) Don't run as root, 5) Use multi-stage builds, 6) Cache dependencies separately, 7) Use specific tags not 'latest', 8) Clean up in the same layer, 9) Use COPY over ADD.",
        example: `# Good Dockerfile
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .

FROM node:18-alpine
RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001
USER nodejs
WORKDIR /app
COPY --from=builder --chown=nodejs:nodejs /app .
CMD ["node", "server.js"]`,
      },
      {
        q: "How do you reduce Docker image size?",
        a: "Reduce image size by: 1) Using alpine-based images, 2) Multi-stage builds to exclude build tools, 3) Combining RUN commands, 4) Removing cache/temp files in same layer, 5) Using .dockerignore, 6) Minimizing installed packages, 7) Using slim variants of images.",
        example: `# Multi-stage for smaller final image
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Use alpine for final image
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
CMD ["node", "dist/main.js"]`,
      },
      {
        q: "What is Docker networking in detail?",
        a: "Docker provides several network drivers: bridge (default, isolated network for containers on same host), host (removes isolation, uses host network directly), overlay (multi-host networking for swarm), macvlan (assigns MAC addresses for physical network integration), none (disables networking).",
        example: `docker network create mynetwork
docker run --network=mynetwork nginx
docker network connect mynetwork container_name
docker network inspect mynetwork`,
      },
      {
        q: "What is Docker security scanning?",
        a: "Docker security scanning analyzes images for known vulnerabilities in base images and dependencies. Tools like Docker Scan (uses Snyk), Trivy, and Clair scan images and report CVEs. Regular scanning is crucial for maintaining secure containerized applications.",
        example: `docker scan myimage:latest
docker scout cves myimage:latest`,
      },
      {
        q: "What is container orchestration?",
        a: "Container orchestration automates deployment, scaling, networking, and management of containerized applications. Tools like Kubernetes and Docker Swarm handle scheduling, load balancing, service discovery, rolling updates, and self-healing of containers across clusters.",
      },
      {
        q: "What are Docker health checks?",
        a: "Docker health checks test whether a container is working correctly. The HEALTHCHECK instruction defines a command that Docker runs periodically. Based on the result, Docker marks the container as healthy or unhealthy, enabling better orchestration and monitoring.",
        example: `# In Dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s \\
  CMD curl -f http://localhost/ || exit 1

# Runtime
docker run --health-cmd='curl -f http://localhost/' \\
           --health-interval=30s myapp`,
      },
    ],
  },
};

// Function to render questions
function renderQuestions() {
  const content = document.getElementById("content");
  const topic = questions.docker;

  if (!topic) {
    content.innerHTML =
      '<div class="welcome-message"><h2>No questions available yet.</h2></div>';
    return;
  }

  let html = "";

  // Render Easy Questions
  if (topic.easy && topic.easy.length > 0) {
    html += '<div class="difficulty-section easy">';
    html += '<div class="difficulty-header">';
    html += '<span class="difficulty-icon">ðŸŸ¢</span>';
    html += "<h2>Easy Questions</h2>";
    html += "</div>";

    topic.easy.forEach((item, index) => {
      html += `
        <div class="question-card expanded" data-question-id="docker-easy-${index}">
          <div class="question-header">
            <span class="question-number">${index + 1}</span>
            <span class="question-text">${item.q}</span>
          </div>
          <div class="answer-section">
            <span class="answer-label">Answer</span>
            <div class="answer-text">${item.a}</div>
            ${
              item.example
                ? `<div class="example-section"><div class="example-label">ðŸ’¡ Example:</div><pre class="example-code">${item.example}</pre></div>`
                : ""
            }
          </div>
        </div>
      `;
    });

    html += "</div>";
  }

  // Render Medium Questions
  if (topic.medium && topic.medium.length > 0) {
    html += '<div class="difficulty-section intermediate">';
    html += '<div class="difficulty-header">';
    html += '<span class="difficulty-icon">ðŸŸ¡</span>';
    html += "<h2>Medium Questions</h2>";
    html += "</div>";

    topic.medium.forEach((item, index) => {
      html += `
        <div class="question-card expanded" data-question-id="docker-medium-${index}">
          <div class="question-header">
            <span class="question-number">${index + 1}</span>
            <span class="question-text">${item.q}</span>
          </div>
          <div class="answer-section">
            <span class="answer-label">Answer</span>
            <div class="answer-text">${item.a}</div>
            ${
              item.example
                ? `<div class="example-section"><div class="example-label">ðŸ’¡ Example:</div><pre class="example-code">${item.example}</pre></div>`
                : ""
            }
          </div>
        </div>
      `;
    });

    html += "</div>";
  }

  // Render Hard Questions
  if (topic.hard && topic.hard.length > 0) {
    html += '<div class="difficulty-section hard">';
    html += '<div class="difficulty-header">';
    html += '<span class="difficulty-icon">ðŸ”´</span>';
    html += "<h2>Hard Questions</h2>";
    html += "</div>";

    topic.hard.forEach((item, index) => {
      html += `
        <div class="question-card expanded" data-question-id="docker-hard-${index}">
          <div class="question-header">
            <span class="question-number">${index + 1}</span>
            <span class="question-text">${item.q}</span>
          </div>
          <div class="answer-section">
            <span class="answer-label">Answer</span>
            <div class="answer-text">${item.a}</div>
            ${
              item.example
                ? `<div class="example-section"><div class="example-label">ðŸ’¡ Example:</div><pre class="example-code">${item.example}</pre></div>`
                : ""
            }
          </div>
        </div>
      `;
    });

    html += "</div>";
  }

  if (html === "") {
    content.innerHTML =
      '<div class="welcome-message"><h2>No questions available yet. Questions will be added soon!</h2></div>';
  } else {
    content.innerHTML = html;
  }
}

// Progress tracking
function getProgress() {
  const progress = localStorage.getItem("questionProgress");
  return progress ? JSON.parse(progress) : {};
}

function updateProgress(questionId) {
  const progressData = getProgress();

  if (!progressData.docker) {
    progressData.docker = [];
  }

  if (!progressData.docker.includes(questionId)) {
    progressData.docker.push(questionId);
    localStorage.setItem("questionProgress", JSON.stringify(progressData));
    updateProgressBar();
  }
}

function updateProgressBar() {
  const progressData = getProgress();
  const totalAnswered = progressData.docker ? progressData.docker.length : 0;
  const totalQuestions = 50;
  const percentage = Math.round((totalAnswered / totalQuestions) * 100);

  const progressFill = document.querySelector(".progress-fill");
  const progressText = document.querySelector(".progress-text");

  if (progressFill) {
    progressFill.style.width = percentage + "%";
  }
  if (progressText) {
    progressText.textContent = `${totalAnswered}/${totalQuestions} Questions Answered (${percentage}%)`;
  }
}

// Toggle answer visibility
function toggleAnswer(card) {
  card.classList.toggle("expanded");

  const questionId = card.dataset.questionId;
  if (questionId && card.classList.contains("expanded")) {
    updateProgress(questionId);
  }
}

// Initialize theme
function initTheme() {
  const savedTheme = localStorage.getItem("theme") || "light";
  if (savedTheme === "dark") {
    document.body.classList.add("dark-mode");
  }
  updateThemeIcon();
}

function toggleTheme() {
  document.body.classList.toggle("dark-mode");
  const isDark = document.body.classList.contains("dark-mode");
  localStorage.setItem("theme", isDark ? "dark" : "light");
  updateThemeIcon();
}

function updateThemeIcon() {
  const themeToggle = document.querySelector(".theme-toggle");
  if (themeToggle) {
    const isDark = document.body.classList.contains("dark-mode");
    themeToggle.textContent = isDark ? "â˜€ï¸" : "ðŸŒ™";
  }
}

// Back to top functionality
function initBackToTop() {
  const backToTopBtn = document.getElementById("backToTop");
  if (!backToTopBtn) return;

  window.addEventListener("scroll", () => {
    if (window.pageYOffset > 300) {
      backToTopBtn.classList.add("visible");
    } else {
      backToTopBtn.classList.remove("visible");
    }
  });

  backToTopBtn.addEventListener("click", () => {
    window.scrollTo({
      top: 0,
      behavior: "smooth",
    });
  });
}

document.addEventListener("DOMContentLoaded", () => {
  initTheme();
  renderQuestions();
  updateProgressBar();
  initBackToTop();

  const themeToggle = document.querySelector(".theme-toggle");
  if (themeToggle) {
    themeToggle.addEventListener("click", toggleTheme);
  }
});
